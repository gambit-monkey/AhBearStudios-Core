using FishNet.Serializing;
using AhBearStudios.Core.Serialization;
using AhBearStudios.Core.Serialization.Models;
using AhBearStudios.Core.Infrastructure.DependencyInjection;
using UnityEngine;

namespace AhBearStudios.Unity.Serialization.FishNet
{
    /// <summary>
    /// Example FishNet custom serializer extensions for common Unity and AhBearStudios types.
    /// These methods follow FishNet's naming conventions and integrate with the AhBearStudios serialization system.
    /// 
    /// In a real implementation, these would be auto-generated by FishNetExtensionMethodGenerator
    /// or manually created for custom types that need special handling.
    /// </summary>
    public static class FishNetSerializerExtensions
    {
        #region Unity Types - Vector3
        
        /// <summary>
        /// Writes Vector3 to the network stream using MemoryPack via AhBearStudios serialization system.
        /// Provides unified serialization with compression, validation, and statistics.
        /// </summary>
        [UseGlobalCustomSerializer]
        public static void WriteVector3(this Writer writer, Vector3 value)
        {
            // Use the AhBearStudios serialization service for unified MemoryPack serialization
            var service = ServiceResolver.Get<ISerializationService>();
            
            // Serialize to bytes using MemoryPack
            var bytes = service.Serialize(value, default, SerializationFormat.FishNet);
            
            // Write the byte array to the network stream
            writer.WriteArraySegmentAndSize(bytes);
        }
        
        /// <summary>
        /// Reads Vector3 from the network stream using MemoryPack via AhBearStudios serialization system.
        /// </summary>
        [UseGlobalCustomSerializer]
        public static Vector3 ReadVector3(this Reader reader)
        {
            // Get the serialization service
            var service = ServiceResolver.Get<ISerializationService>();
            
            // Read the byte array from network stream
            var bytes = reader.ReadArraySegmentAndSize();
            
            // Deserialize using MemoryPack
            return service.Deserialize<Vector3>(bytes.ToArray(), default, SerializationFormat.FishNet);
        }
        
        #endregion
        
        #region Unity Types - Quaternion
        
        /// <summary>
        /// Writes Quaternion to the network stream using MemoryPack via AhBearStudios serialization system.
        /// MemoryPack provides optimal compression and serialization for all data types.
        /// </summary>
        [UseGlobalCustomSerializer]
        public static void WriteQuaternion(this Writer writer, Quaternion value)
        {
            // Use the AhBearStudios serialization service for unified MemoryPack serialization
            var service = ServiceResolver.Get<ISerializationService>();
            
            // Serialize to bytes using MemoryPack (handles optimal compression automatically)
            var bytes = service.Serialize(value, default, SerializationFormat.FishNet);
            
            // Write the byte array to the network stream
            writer.WriteArraySegmentAndSize(bytes);
        }
        
        /// <summary>
        /// Reads Quaternion from the network stream using MemoryPack via AhBearStudios serialization system.
        /// </summary>
        [UseGlobalCustomSerializer]
        public static Quaternion ReadQuaternion(this Reader reader)
        {
            // Get the serialization service
            var service = ServiceResolver.Get<ISerializationService>();
            
            // Read the byte array from network stream
            var bytes = reader.ReadArraySegmentAndSize();
            
            // Deserialize using MemoryPack
            return service.Deserialize<Quaternion>(bytes.ToArray(), default, SerializationFormat.FishNet);
        }
        
        #endregion
        
        #region High-Performance Pooled Buffer Methods
        
        /// <summary>
        /// High-performance Vector3 serialization using pooled buffers for zero-allocation operations.
        /// Use this for performance-critical scenarios where allocation is a concern.
        /// </summary>
        [UseGlobalCustomSerializer]
        public static void WriteVector3Pooled(this Writer writer, Vector3 value)
        {
            var bufferPool = ServiceResolver.Get<Pooling.Services.NetworkSerializationBufferPool>();
            var service = ServiceResolver.Get<ISerializationService>();
            
            // Get a small buffer from the pool (Vector3 is small)
            var buffer = bufferPool.GetSmallBuffer();
            try
            {
                // Serialize directly to the pooled buffer
                var bytes = service.Serialize(value, default, SerializationFormat.FishNet);
                buffer.SetData(bytes);
                
                // Write to FishNet stream
                writer.WriteArraySegmentAndSize(buffer.GetData().ToArray());
            }
            finally
            {
                // Always return buffer to pool
                bufferPool.ReturnBuffer(buffer);
            }
        }
        
        /// <summary>
        /// High-performance Quaternion serialization using pooled buffers for zero-allocation operations.
        /// </summary>
        [UseGlobalCustomSerializer]
        public static void WriteQuaternionPooled(this Writer writer, Quaternion value)
        {
            var bufferPool = ServiceResolver.Get<Pooling.Services.NetworkSerializationBufferPool>();
            var service = ServiceResolver.Get<ISerializationService>();
            
            // Get a small buffer from the pool (Quaternion is small)
            var buffer = bufferPool.GetSmallBuffer();
            try
            {
                // Serialize directly to the pooled buffer
                var bytes = service.Serialize(value, default, SerializationFormat.FishNet);
                buffer.SetData(bytes);
                
                // Write to FishNet stream
                writer.WriteArraySegmentAndSize(buffer.GetData().ToArray());
            }
            finally
            {
                // Always return buffer to pool
                bufferPool.ReturnBuffer(buffer);
            }
        }
        
        /// <summary>
        /// Generic high-performance serialization method using pooled buffers.
        /// Automatically selects appropriate buffer size based on type.
        /// </summary>
        [UseGlobalCustomSerializer]
        public static void WritePooled<T>(this Writer writer, T value) where T : unmanaged
        {
            var bufferPool = ServiceResolver.Get<Pooling.Services.NetworkSerializationBufferPool>();
            var service = ServiceResolver.Get<ISerializationService>();
            
            // Estimate buffer size based on type (rough heuristic)
            var typeSize = System.Runtime.InteropServices.Marshal.SizeOf<T>();
            var expectedSize = typeSize * 2; // Account for MemoryPack overhead
            
            var buffer = bufferPool.GetBuffer(expectedSize);
            try
            {
                // Serialize directly to the pooled buffer
                var bytes = service.Serialize(value, default, SerializationFormat.FishNet);
                buffer.SetData(bytes);
                
                // Write to FishNet stream
                writer.WriteArraySegmentAndSize(buffer.GetData().ToArray());
            }
            finally
            {
                // Always return buffer to pool
                bufferPool.ReturnBuffer(buffer);
            }
        }
        
        #endregion
        
        #region Custom Game Types - Example
        
        /// <summary>
        /// Example custom game data structure that would be serialized over the network.
        /// This demonstrates how to integrate AhBearStudios serialization with FishNet.
        /// </summary>
        [System.Serializable]
        public struct PlayerNetworkData
        {
            public int PlayerId;
            public Vector3 Position;
            public Quaternion Rotation;
            public float Health;
            public string PlayerName;
        }
        
        /// <summary>
        /// Writes PlayerNetworkData using a hybrid approach:
        /// - Simple types directly for performance
        /// - Complex types through AhBearStudios serialization system
        /// </summary>
        [UseGlobalCustomSerializer]
        public static void WritePlayerNetworkData(this Writer writer, PlayerNetworkData value)
        {
            // Write simple fields directly for optimal performance
            writer.WriteInt32(value.PlayerId);
            writer.WriteVector3(value.Position);  // Uses our custom Vector3 serializer
            writer.WriteQuaternion(value.Rotation); // Uses our custom Quaternion serializer
            writer.WriteSingle(value.Health);
            writer.WriteString(value.PlayerName ?? string.Empty);
        }
        
        /// <summary>
        /// Reads PlayerNetworkData from the network stream.
        /// </summary>
        [UseGlobalCustomSerializer]
        public static PlayerNetworkData ReadPlayerNetworkData(this Reader reader)
        {
            return new PlayerNetworkData
            {
                PlayerId = reader.ReadInt32(),
                Position = reader.ReadVector3(),    // Uses our custom Vector3 deserializer
                Rotation = reader.ReadQuaternion(), // Uses our custom Quaternion deserializer
                Health = reader.ReadSingle(),
                PlayerName = reader.ReadString()
            };
        }
        
        #endregion
        
        #region Complex Types Using AhBearStudios Serialization
        
        /// <summary>
        /// Example of serializing a complex type through the AhBearStudios serialization system.
        /// This approach is useful for types that have custom serialization logic or are not network-optimized.
        /// </summary>
        [UseGlobalCustomSerializer]
        public static void WriteComplexGameData(this Writer writer, ComplexGameData value)
        {
            // Use the AhBearStudios serialization service for complex types
            var service = ServiceResolver.Get<ISerializationService>();
            
            // Serialize to bytes using the configured serialization format
            var bytes = service.Serialize(value, default, SerializationFormat.FishNet);
            
            // Write the byte array to the network stream
            writer.WriteArraySegmentAndSize(bytes);
        }
        
        /// <summary>
        /// Reads complex game data using the AhBearStudios serialization system.
        /// </summary>
        [UseGlobalCustomSerializer]
        public static ComplexGameData ReadComplexGameData(this Reader reader)
        {
            // Get the serialization service
            var service = ServiceResolver.Get<ISerializationService>();
            
            // Read the byte array from network stream
            var bytes = reader.ReadArraySegmentAndSize();
            
            // Deserialize using the configured format
            return service.Deserialize<ComplexGameData>(bytes.ToArray(), default, SerializationFormat.FishNet);
        }
        
        /// <summary>
        /// Example complex game data that would benefit from using the full serialization system.
        /// </summary>
        [System.Serializable]
        public class ComplexGameData
        {
            public Dictionary<string, int> PlayerScores;
            public List<Vector3> WaypointPath;
            public DateTime LastUpdated;
            public System.Guid SessionId;
            
            // Complex nested data that would be handled by MemoryPack or other serializers
            public NestedGameStats Stats;
        }
        
        [System.Serializable]
        public class NestedGameStats
        {
            public float[] DamageHistory;
            public Dictionary<int, PlayerStats> PlayerStatistics;
            public CustomGameSettings Settings;
        }
        
        [System.Serializable]
        public struct PlayerStats
        {
            public int Kills;
            public int Deaths;
            public float Accuracy;
            public TimeSpan PlayTime;
        }
        
        [System.Serializable]
        public class CustomGameSettings
        {
            public bool FriendlyFire;
            public float RespawnTime;
            public int MaxPlayers;
            public string MapName;
        }
        
        #endregion
    }
}